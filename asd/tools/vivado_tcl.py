"""TCL template generation for Vivado OOC synthesis."""

from pathlib import Path
from typing import Any

OOC_SYNTHESIS_TEMPLATE = """\
# Auto-generated by ASD - Out-of-Context Synthesis
# Module: {module_name}
# Configuration: {configuration}
# Part: {part}

create_project -in_memory -part {part}
set_property target_language Verilog [current_project]

# Read sources
{read_sources}

# Synthesis (OOC mode)
synth_design -top {top} \\
    -mode out_of_context \\
    -flatten_hierarchy none \\
    -directive {synth_directive}{parameters}{defines}

# Clock constraints for OOC
{clock_constraints}

# Post-synthesis optimization
opt_design

# Reports
file mkdir {reports_dir}
report_utilization -file {reports_dir}/{label}_UTILIZATION.rpt
report_timing_summary -file {reports_dir}/{label}_TIMING.rpt

# Save checkpoint
write_checkpoint -force {build_dir}/{label}_SYNTHESIS.dcp

# Placement
place_design -directive {place_directive}
write_checkpoint -force {build_dir}/{label}_PLACED.dcp
report_timing_summary -file {reports_dir}/{label}_PLACED_TIMING.rpt

# Routing
route_design -directive {route_directive}
write_checkpoint -force {build_dir}/{label}_ROUTED.dcp
report_timing_summary -file {reports_dir}/{label}_ROUTED_TIMING.rpt
report_utilization -file {reports_dir}/{label}_ROUTED_UTILIZATION.rpt

puts "Synthesis complete: {label}"
"""


def generate_clock_constraints(clocks: dict[str, float], uncertainty: float | None) -> str:
    """Generate TCL clock constraints for OOC synthesis.

    Args:
        clocks: Dictionary mapping clock port names to periods in ns
        uncertainty: Optional clock uncertainty value

    Returns:
        TCL commands for clock constraints
    """
    lines: list[str] = []
    for i, (name, period) in enumerate(clocks.items()):
        lines.append(f"create_clock -name {name} -period {period} [get_ports {name}]")
        lines.append(f"set_property HD.CLK_SRC BUFGCTRL_X0Y{i} [get_ports {name}]")
    if uncertainty is not None:
        lines.append(f"set_clock_uncertainty {uncertainty} [all_clocks]")
    return "\n".join(lines)


def generate_read_sources(sources: list[Path], packages: list[Path]) -> str:
    """Generate TCL read_verilog commands.

    Args:
        sources: List of source file paths
        packages: List of package file paths (read first)

    Returns:
        TCL commands to read all source files
    """
    lines: list[str] = []
    for pkg in packages:
        lines.append(f"read_verilog -sv {{{pkg}}}")
    for src in sources:
        lines.append(f"read_verilog -sv {{{src}}}")
    return "\n".join(lines)


def _stringify_value(value: Any) -> str:
    """Convert a parameter value to Vivado-compatible string.

    Args:
        value: Parameter value (int, bool, str, etc.)

    Returns:
        String representation for Vivado
    """
    if isinstance(value, bool):
        return "1" if value else "0"
    return str(value)


def generate_parameters(params: dict[str, Any]) -> str:
    """Generate -generic arguments for synth_design.

    Args:
        params: Dictionary of parameter names to values

    Returns:
        TCL -generic arguments string
    """
    if not params:
        return ""
    lines = [f"-generic {k}={_stringify_value(v)}" for k, v in params.items()]
    return " \\\n    " + " \\\n    ".join(lines)


def generate_defines(defines: dict[str, Any]) -> str:
    """Generate -verilog_define arguments for synth_design.

    Args:
        defines: Dictionary of define names to values

    Returns:
        TCL -verilog_define arguments string
    """
    if not defines:
        return ""
    lines: list[str] = []
    for k, v in defines.items():
        if v is True:
            lines.append(f"-verilog_define {k}")
        elif v is not False:
            lines.append(f"-verilog_define {k}={_stringify_value(v)}")
    if not lines:
        return ""
    return " \\\n    " + " \\\n    ".join(lines)


def generate_ooc_tcl(
    module_name: str,
    top: str,
    configuration: str,
    part: str,
    sources: list[Path],
    packages: list[Path],
    parameters: dict[str, Any],
    defines: dict[str, Any],
    clocks: dict[str, float],
    clock_uncertainty: float | None,
    synth_directive: str,
    place_directive: str,
    route_directive: str,
    build_dir: Path,
    label: str,
) -> str:
    """Generate complete OOC synthesis TCL script.

    Args:
        module_name: Module name from TOML
        top: Top module name
        configuration: Configuration name
        part: FPGA part number
        sources: List of source file paths
        packages: List of package file paths
        parameters: Parameter values
        defines: Define values
        clocks: Clock port names to periods
        clock_uncertainty: Optional clock uncertainty
        synth_directive: Synthesis directive
        place_directive: Placement directive
        route_directive: Routing directive
        build_dir: Build directory path
        label: Label for output files

    Returns:
        Complete TCL script as string
    """
    return OOC_SYNTHESIS_TEMPLATE.format(
        module_name=module_name,
        top=top,
        configuration=configuration,
        part=part,
        read_sources=generate_read_sources(sources, packages),
        parameters=generate_parameters(parameters),
        defines=generate_defines(defines),
        clock_constraints=generate_clock_constraints(clocks, clock_uncertainty),
        synth_directive=synth_directive,
        place_directive=place_directive,
        route_directive=route_directive,
        build_dir=build_dir,
        reports_dir=build_dir / "reports",
        label=label,
    )
